; This is the Calva evaluation results output window.
; TIPS: The keyboard shortcut `ctrl+alt+o o` shows and focuses this window
;   when connected to a REPL session.
; Please see https://calva.io/output/ for more info.
; Happy coding! ♥️

; Jacking in...
; Connecting using "Babashka" project type.
; You can make Calva auto-select this.
;   - See https://calva.io/connect-sequences/
; 
; Starting Jack-in Terminal: pushd c:\Users\alvar\Clojure code\Itz9Am.github.io & bb --nrepl-server 60330 & popd
; Jacking in...
; Connecting using "nbb" project type.
; You can make Calva auto-select this.
;   - See https://calva.io/connect-sequences/
; 
; Starting Jack-in Terminal: pushd c:\Users\alvar\Clojure code\Itz9Am.github.io & npx.cmd nbb nrepl-server :port 60341 & popd
; Using host:port 127.0.0.1:60341 ...
; Hooking up nREPL sessions ...
; Connected session: clj
; TIPS:
;   - You can edit the contents here. Use it as a REPL if you like.
;   - `alt+enter` evaluates the current top level form.
;   - `ctrl+enter` evaluates the current form.
;   - `alt+up` and `alt+down` traverse up and down the REPL command history
;      when the cursor is after the last contents at the prompt
;   - Clojure lines in stack traces are peekable and clickable.
clj꞉user꞉>  ; Use `alt+enter` to evaluate
; Creating cljs repl session...
; Connecting cljs repl: nbb...
;   The Calva Connection Log might have more connection progress information.
; Connected session: cljs
; TIPS: You can choose which REPL to use (clj or cljs):
;    *Calva: Toggle REPL connection*
;    (There is a button in the status bar for this)
; Jack-in done.
cljs꞉cljs.user꞉>  ; Use `alt+enter` to evaluate
; Evaluating file: core.cljs
; Cannot use 'in' operator to search for 'getElementById' in undefined
; Evaluation of file core.cljs failed: #error {:message "Cannot use 'in' operator to search for 'getElementById' in undefined", :data {:type :sci/error, :line 34, :column 20, :message "Cannot use 'in' operator to search for 'getElementById' in undefined", :sci.impl/callstack #object[cljs.core.Volatile {:val ({:line 33, :column 1, :ns #object[Ir crypta.core], :file "(ns crypta.core\r\n  \"Crypta\" \r\n  (:require [clojure.string :as str]))\r\n\r\n;(def key-vector [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 1 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7])\r\n(def key-vector (atom [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7]))\r\n\r\n(def inv-key (map - key-vector))\r\n\r\n(def num->alpha (zipmap (range 29)\r\n                        \"abcdefghijklmnopqrstuvwxyzåäö\"))\r\n(def alpha->num (zipmap \"abcdefghijklmnopqrstuvwxyzåäö\"\r\n                        (range 29)))\r\n\r\n(defn code-letter [letter key-digit] \r\n    (num->alpha (mod (+ 29 (alpha->num letter) key-digit) 29)))\r\n\r\n(defn code-msg [msg key]\r\n  (when (seq msg)\r\n    (let [letter (first msg)\r\n          key-digit (first key)]\r\n      (if (= letter \\space)\r\n        (cons letter (code-msg (rest msg) key))\r\n        (cons (code-letter letter key-digit)\r\n              (code-msg (rest msg) (rest key)))))))\r\n\r\n(defn encode [input] (apply str (code-msg (str/lower-case input) (cycle key-vector))))\r\n\r\n(defn decode [code] (apply str (code-msg (str/lower-case code) (cycle inv-key))))\r\n\r\n;; HTML helpers\r\n\r\n(defn attach-input-handler! [element-id handler]\r\n  (set! (.-oninput (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn attach-change-handler! [element-id handler]\r\n  (set! (.-onchange (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn set-value! [element-id value]\r\n  (set! (.-value (js/document.getElementById element-id)) value))\r\n\r\n(defn get-value [element-id]\r\n  (.-value (js/document.getElementById element-id)))\r\n\r\n(defn copy-to-clipboard! [value]\r\n  (js/navigator.clipboard.writeText value))\r\n\r\n;; Handlers\r\n\r\n(defn on-encode [arg]\r\n  (set-value! \"decode\" (encode arg)))\r\n\r\n(defn on-decode [arg]\r\n  (set-value! \"encode\" (decode arg)))\r\n\r\n(defn on-change [arg]\r\n  (copy-to-clipboard! (get-value \"decode\"))\r\n  (set-value! \"decode\" \"\")\r\n  (set-value! \"encode\" \"\"))\r\n\r\n(attach-input-handler! \"encode\" on-encode)\r\n(attach-input-handler! \"decode\" on-decode)\r\n(attach-change-handler! \"encode\" on-change)\r\n(attach-change-handler! \"decode\" on-change)\r\n(attach-change-handler! \"key\" (get-value \"key\"))"} {:line 33, :column 1, :ns #object[Ir crypta.core], :file "(ns crypta.core\r\n  \"Crypta\" \r\n  (:require [clojure.string :as str]))\r\n\r\n;(def key-vector [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 1 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7])\r\n(def key-vector (atom [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7]))\r\n\r\n(def inv-key (map - key-vector))\r\n\r\n(def num->alpha (zipmap (range 29)\r\n                        \"abcdefghijklmnopqrstuvwxyzåäö\"))\r\n(def alpha->num (zipmap \"abcdefghijklmnopqrstuvwxyzåäö\"\r\n                        (range 29)))\r\n\r\n(defn code-letter [letter key-digit] \r\n    (num->alpha (mod (+ 29 (alpha->num letter) key-digit) 29)))\r\n\r\n(defn code-msg [msg key]\r\n  (when (seq msg)\r\n    (let [letter (first msg)\r\n          key-digit (first key)]\r\n      (if (= letter \\space)\r\n        (cons letter (code-msg (rest msg) key))\r\n        (cons (code-letter letter key-digit)\r\n              (code-msg (rest msg) (rest key)))))))\r\n\r\n(defn encode [input] (apply str (code-msg (str/lower-case input) (cycle key-vector))))\r\n\r\n(defn decode [code] (apply str (code-msg (str/lower-case code) (cycle inv-key))))\r\n\r\n;; HTML helpers\r\n\r\n(defn attach-input-handler! [element-id handler]\r\n  (set! (.-oninput (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn attach-change-handler! [element-id handler]\r\n  (set! (.-onchange (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn set-value! [element-id value]\r\n  (set! (.-value (js/document.getElementById element-id)) value))\r\n\r\n(defn get-value [element-id]\r\n  (.-value (js/document.getElementById element-id)))\r\n\r\n(defn copy-to-clipboard! [value]\r\n  (js/navigator.clipboard.writeText value))\r\n\r\n;; Handlers\r\n\r\n(defn on-encode [arg]\r\n  (set-value! \"decode\" (encode arg)))\r\n\r\n(defn on-decode [arg]\r\n  (set-value! \"encode\" (decode arg)))\r\n\r\n(defn on-change [arg]\r\n  (copy-to-clipboard! (get-value \"decode\"))\r\n  (set-value! \"decode\" \"\")\r\n  (set-value! \"encode\" \"\"))\r\n\r\n(attach-input-handler! \"encode\" on-encode)\r\n(attach-input-handler! \"decode\" on-decode)\r\n(attach-change-handler! \"encode\" on-change)\r\n(attach-change-handler! \"decode\" on-change)\r\n(attach-change-handler! \"key\" (get-value \"key\"))", :sci.impl/f-meta {:ns #object[Ir clojure.core], :macro true, :sci/built-in true, :name defn, :arglists ([name doc-string? attr-map? [params*] prepost-map? body] [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]), :doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions."}} {:line 33, :column 1, :ns #object[Ir crypta.core], :file "(ns crypta.core\r\n  \"Crypta\" \r\n  (:require [clojure.string :as str]))\r\n\r\n;(def key-vector [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 1 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7])\r\n(def key-vector (atom [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7]))\r\n\r\n(def inv-key (map - key-vector))\r\n\r\n(def num->alpha (zipmap (range 29)\r\n                        \"abcdefghijklmnopqrstuvwxyzåäö\"))\r\n(def alpha->num (zipmap \"abcdefghijklmnopqrstuvwxyzåäö\"\r\n                        (range 29)))\r\n\r\n(defn code-letter [letter key-digit] \r\n    (num->alpha (mod (+ 29 (alpha->num letter) key-digit) 29)))\r\n\r\n(defn code-msg [msg key]\r\n  (when (seq msg)\r\n    (let [letter (first msg)\r\n          key-digit (first key)]\r\n      (if (= letter \\space)\r\n        (cons letter (code-msg (rest msg) key))\r\n        (cons (code-letter letter key-digit)\r\n              (code-msg (rest msg) (rest key)))))))\r\n\r\n(defn encode [input] (apply str (code-msg (str/lower-case input) (cycle key-vector))))\r\n\r\n(defn decode [code] (apply str (code-msg (str/lower-case code) (cycle inv-key))))\r\n\r\n;; HTML helpers\r\n\r\n(defn attach-input-handler! [element-id handler]\r\n  (set! (.-oninput (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn attach-change-handler! [element-id handler]\r\n  (set! (.-onchange (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn set-value! [element-id value]\r\n  (set! (.-value (js/document.getElementById element-id)) value))\r\n\r\n(defn get-value [element-id]\r\n  (.-value (js/document.getElementById element-id)))\r\n\r\n(defn copy-to-clipboard! [value]\r\n  (js/navigator.clipboard.writeText value))\r\n\r\n;; Handlers\r\n\r\n(defn on-encode [arg]\r\n  (set-value! \"decode\" (encode arg)))\r\n\r\n(defn on-decode [arg]\r\n  (set-value! \"encode\" (decode arg)))\r\n\r\n(defn on-change [arg]\r\n  (copy-to-clipboard! (get-value \"decode\"))\r\n  (set-value! \"decode\" \"\")\r\n  (set-value! \"encode\" \"\"))\r\n\r\n(attach-input-handler! \"encode\" on-encode)\r\n(attach-input-handler! \"decode\" on-decode)\r\n(attach-change-handler! \"encode\" on-change)\r\n(attach-change-handler! \"decode\" on-change)\r\n(attach-change-handler! \"key\" (get-value \"key\"))"} {:sci.impl/fn {:macro nil, :fn-name attach-input-handler!}, :ns #object[Ir crypta.core], :file "(ns crypta.core\r\n  \"Crypta\" \r\n  (:require [clojure.string :as str]))\r\n\r\n;(def key-vector [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 1 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7])\r\n(def key-vector (atom [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7]))\r\n\r\n(def inv-key (map - key-vector))\r\n\r\n(def num->alpha (zipmap (range 29)\r\n                        \"abcdefghijklmnopqrstuvwxyzåäö\"))\r\n(def alpha->num (zipmap \"abcdefghijklmnopqrstuvwxyzåäö\"\r\n                        (range 29)))\r\n\r\n(defn code-letter [letter key-digit] \r\n    (num->alpha (mod (+ 29 (alpha->num letter) key-digit) 29)))\r\n\r\n(defn code-msg [msg key]\r\n  (when (seq msg)\r\n    (let [letter (first msg)\r\n          key-digit (first key)]\r\n      (if (= letter \\space)\r\n        (cons letter (code-msg (rest msg) key))\r\n        (cons (code-letter letter key-digit)\r\n              (code-msg (rest msg) (rest key)))))))\r\n\r\n(defn encode [input] (apply str (code-msg (str/lower-case input) (cycle key-vector))))\r\n\r\n(defn decode [code] (apply str (code-msg (str/lower-case code) (cycle inv-key))))\r\n\r\n;; HTML helpers\r\n\r\n(defn attach-input-handler! [element-id handler]\r\n  (set! (.-oninput (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn attach-change-handler! [element-id handler]\r\n  (set! (.-onchange (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn set-value! [element-id value]\r\n  (set! (.-value (js/document.getElementById element-id)) value))\r\n\r\n(defn get-value [element-id]\r\n  (.-value (js/document.getElementById element-id)))\r\n\r\n(defn copy-to-clipboard! [value]\r\n  (js/navigator.clipboard.writeText value))\r\n\r\n;; Handlers\r\n\r\n(defn on-encode [arg]\r\n  (set-value! \"decode\" (encode arg)))\r\n\r\n(defn on-decode [arg]\r\n  (set-value! \"encode\" (decode arg)))\r\n\r\n(defn on-change [arg]\r\n  (copy-to-clipboard! (get-value \"decode\"))\r\n  (set-value! \"decode\" \"\")\r\n  (set-value! \"encode\" \"\"))\r\n\r\n(attach-input-handler! \"encode\" on-encode)\r\n(attach-input-handler! \"decode\" on-decode)\r\n(attach-change-handler! \"encode\" on-change)\r\n(attach-change-handler! \"decode\" on-change)\r\n(attach-change-handler! \"key\" (get-value \"key\"))"} {:sci.impl/fn {:macro nil, :fn-name attach-input-handler!}, :ns #object[Ir crypta.core], :file "(ns crypta.core\r\n  \"Crypta\" \r\n  (:require [clojure.string :as str]))\r\n\r\n;(def key-vector [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 1 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7])\r\n(def key-vector (atom [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7]))\r\n\r\n(def inv-key (map - key-vector))\r\n\r\n(def num->alpha (zipmap (range 29)\r\n                        \"abcdefghijklmnopqrstuvwxyzåäö\"))\r\n(def alpha->num (zipmap \"abcdefghijklmnopqrstuvwxyzåäö\"\r\n                        (range 29)))\r\n\r\n(defn code-letter [letter key-digit] \r\n    (num->alpha (mod (+ 29 (alpha->num letter) key-digit) 29)))\r\n\r\n(defn code-msg [msg key]\r\n  (when (seq msg)\r\n    (let [letter (first msg)\r\n          key-digit (first key)]\r\n      (if (= letter \\space)\r\n        (cons letter (code-msg (rest msg) key))\r\n        (cons (code-letter letter key-digit)\r\n              (code-msg (rest msg) (rest key)))))))\r\n\r\n(defn encode [input] (apply str (code-msg (str/lower-case input) (cycle key-vector))))\r\n\r\n(defn decode [code] (apply str (code-msg (str/lower-case code) (cycle inv-key))))\r\n\r\n;; HTML helpers\r\n\r\n(defn attach-input-handler! [element-id handler]\r\n  (set! (.-oninput (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn attach-change-handler! [element-id handler]\r\n  (set! (.-onchange (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn set-value! [element-id value]\r\n  (set! (.-value (js/document.getElementById element-id)) value))\r\n\r\n(defn get-value [element-id]\r\n  (.-value (js/document.getElementById element-id)))\r\n\r\n(defn copy-to-clipboard! [value]\r\n  (js/navigator.clipboard.writeText value))\r\n\r\n;; Handlers\r\n\r\n(defn on-encode [arg]\r\n  (set-value! \"decode\" (encode arg)))\r\n\r\n(defn on-decode [arg]\r\n  (set-value! \"encode\" (decode arg)))\r\n\r\n(defn on-change [arg]\r\n  (copy-to-clipboard! (get-value \"decode\"))\r\n  (set-value! \"decode\" \"\")\r\n  (set-value! \"encode\" \"\"))\r\n\r\n(attach-input-handler! \"encode\" on-encode)\r\n(attach-input-handler! \"decode\" on-decode)\r\n(attach-change-handler! \"encode\" on-change)\r\n(attach-change-handler! \"decode\" on-change)\r\n(attach-change-handler! \"key\" (get-value \"key\"))", :sci.impl/f-meta {:ns #object[Ir clojure.core], :macro true, :sci/built-in true, :name fn, :arglists ([& sigs]), :doc "params => positional-params* , or positional-params* & next-param\n  positional-param => binding-form\n  next-param => binding-form\n  name => symbol\n\n  Defines a function"}} {:sci.impl/fn {:macro nil, :fn-name attach-input-handler!}, :ns #object[Ir crypta.core], :file "(ns crypta.core\r\n  \"Crypta\" \r\n  (:require [clojure.string :as str]))\r\n\r\n;(def key-vector [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 1 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7])\r\n(def key-vector (atom [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7]))\r\n\r\n(def inv-key (map - key-vector))\r\n\r\n(def num->alpha (zipmap (range 29)\r\n                        \"abcdefghijklmnopqrstuvwxyzåäö\"))\r\n(def alpha->num (zipmap \"abcdefghijklmnopqrstuvwxyzåäö\"\r\n                        (range 29)))\r\n\r\n(defn code-letter [letter key-digit] \r\n    (num->alpha (mod (+ 29 (alpha->num letter) key-digit) 29)))\r\n\r\n(defn code-msg [msg key]\r\n  (when (seq msg)\r\n    (let [letter (first msg)\r\n          key-digit (first key)]\r\n      (if (= letter \\space)\r\n        (cons letter (code-msg (rest msg) key))\r\n        (cons (code-letter letter key-digit)\r\n              (code-msg (rest msg) (rest key)))))))\r\n\r\n(defn encode [input] (apply str (code-msg (str/lower-case input) (cycle key-vector))))\r\n\r\n(defn decode [code] (apply str (code-msg (str/lower-case code) (cycle inv-key))))\r\n\r\n;; HTML helpers\r\n\r\n(defn attach-input-handler! [element-id handler]\r\n  (set! (.-oninput (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn attach-change-handler! [element-id handler]\r\n  (set! (.-onchange (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn set-value! [element-id value]\r\n  (set! (.-value (js/document.getElementById element-id)) value))\r\n\r\n(defn get-value [element-id]\r\n  (.-value (js/document.getElementById element-id)))\r\n\r\n(defn copy-to-clipboard! [value]\r\n  (js/navigator.clipboard.writeText value))\r\n\r\n;; Handlers\r\n\r\n(defn on-encode [arg]\r\n  (set-value! \"decode\" (encode arg)))\r\n\r\n(defn on-decode [arg]\r\n  (set-value! \"encode\" (decode arg)))\r\n\r\n(defn on-change [arg]\r\n  (copy-to-clipboard! (get-value \"decode\"))\r\n  (set-value! \"decode\" \"\")\r\n  (set-value! \"encode\" \"\"))\r\n\r\n(attach-input-handler! \"encode\" on-encode)\r\n(attach-input-handler! \"decode\" on-decode)\r\n(attach-change-handler! \"encode\" on-change)\r\n(attach-change-handler! \"decode\" on-change)\r\n(attach-change-handler! \"key\" (get-value \"key\"))"} {:line 34, :column 3, :ns #object[Ir crypta.core], :file "(ns crypta.core\r\n  \"Crypta\" \r\n  (:require [clojure.string :as str]))\r\n\r\n;(def key-vector [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 1 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7])\r\n(def key-vector (atom [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7]))\r\n\r\n(def inv-key (map - key-vector))\r\n\r\n(def num->alpha (zipmap (range 29)\r\n                        \"abcdefghijklmnopqrstuvwxyzåäö\"))\r\n(def alpha->num (zipmap \"abcdefghijklmnopqrstuvwxyzåäö\"\r\n                        (range 29)))\r\n\r\n(defn code-letter [letter key-digit] \r\n    (num->alpha (mod (+ 29 (alpha->num letter) key-digit) 29)))\r\n\r\n(defn code-msg [msg key]\r\n  (when (seq msg)\r\n    (let [letter (first msg)\r\n          key-digit (first key)]\r\n      (if (= letter \\space)\r\n        (cons letter (code-msg (rest msg) key))\r\n        (cons (code-letter letter key-digit)\r\n              (code-msg (rest msg) (rest key)))))))\r\n\r\n(defn encode [input] (apply str (code-msg (str/lower-case input) (cycle key-vector))))\r\n\r\n(defn decode [code] (apply str (code-msg (str/lower-case code) (cycle inv-key))))\r\n\r\n;; HTML helpers\r\n\r\n(defn attach-input-handler! [element-id handler]\r\n  (set! (.-oninput (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn attach-change-handler! [element-id handler]\r\n  (set! (.-onchange (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn set-value! [element-id value]\r\n  (set! (.-value (js/document.getElementById element-id)) value))\r\n\r\n(defn get-value [element-id]\r\n  (.-value (js/document.getElementById element-id)))\r\n\r\n(defn copy-to-clipboard! [value]\r\n  (js/navigator.clipboard.writeText value))\r\n\r\n;; Handlers\r\n\r\n(defn on-encode [arg]\r\n  (set-value! \"decode\" (encode arg)))\r\n\r\n(defn on-decode [arg]\r\n  (set-value! \"encode\" (decode arg)))\r\n\r\n(defn on-change [arg]\r\n  (copy-to-clipboard! (get-value \"decode\"))\r\n  (set-value! \"decode\" \"\")\r\n  (set-value! \"encode\" \"\"))\r\n\r\n(attach-input-handler! \"encode\" on-encode)\r\n(attach-input-handler! \"decode\" on-decode)\r\n(attach-change-handler! \"encode\" on-change)\r\n(attach-change-handler! \"decode\" on-change)\r\n(attach-change-handler! \"key\" (get-value \"key\"))"} {:line 34, :column 9, :ns #object[Ir crypta.core], :file "(ns crypta.core\r\n  \"Crypta\" \r\n  (:require [clojure.string :as str]))\r\n\r\n;(def key-vector [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 1 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7])\r\n(def key-vector (atom [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7]))\r\n\r\n(def inv-key (map - key-vector))\r\n\r\n(def num->alpha (zipmap (range 29)\r\n                        \"abcdefghijklmnopqrstuvwxyzåäö\"))\r\n(def alpha->num (zipmap \"abcdefghijklmnopqrstuvwxyzåäö\"\r\n                        (range 29)))\r\n\r\n(defn code-letter [letter key-digit] \r\n    (num->alpha (mod (+ 29 (alpha->num letter) key-digit) 29)))\r\n\r\n(defn code-msg [msg key]\r\n  (when (seq msg)\r\n    (let [letter (first msg)\r\n          key-digit (first key)]\r\n      (if (= letter \\space)\r\n        (cons letter (code-msg (rest msg) key))\r\n        (cons (code-letter letter key-digit)\r\n              (code-msg (rest msg) (rest key)))))))\r\n\r\n(defn encode [input] (apply str (code-msg (str/lower-case input) (cycle key-vector))))\r\n\r\n(defn decode [code] (apply str (code-msg (str/lower-case code) (cycle inv-key))))\r\n\r\n;; HTML helpers\r\n\r\n(defn attach-input-handler! [element-id handler]\r\n  (set! (.-oninput (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn attach-change-handler! [element-id handler]\r\n  (set! (.-onchange (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn set-value! [element-id value]\r\n  (set! (.-value (js/document.getElementById element-id)) value))\r\n\r\n(defn get-value [element-id]\r\n  (.-value (js/document.getElementById element-id)))\r\n\r\n(defn copy-to-clipboard! [value]\r\n  (js/navigator.clipboard.writeText value))\r\n\r\n;; Handlers\r\n\r\n(defn on-encode [arg]\r\n  (set-value! \"decode\" (encode arg)))\r\n\r\n(defn on-decode [arg]\r\n  (set-value! \"encode\" (decode arg)))\r\n\r\n(defn on-change [arg]\r\n  (copy-to-clipboard! (get-value \"decode\"))\r\n  (set-value! \"decode\" \"\")\r\n  (set-value! \"encode\" \"\"))\r\n\r\n(attach-input-handler! \"encode\" on-encode)\r\n(attach-input-handler! \"decode\" on-decode)\r\n(attach-change-handler! \"encode\" on-change)\r\n(attach-change-handler! \"decode\" on-change)\r\n(attach-change-handler! \"key\" (get-value \"key\"))"} {:line 34, :column 20, :ns #object[Ir crypta.core], :file "(ns crypta.core\r\n  \"Crypta\" \r\n  (:require [clojure.string :as str]))\r\n\r\n;(def key-vector [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 1 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7])\r\n(def key-vector (atom [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7]))\r\n\r\n(def inv-key (map - key-vector))\r\n\r\n(def num->alpha (zipmap (range 29)\r\n                        \"abcdefghijklmnopqrstuvwxyzåäö\"))\r\n(def alpha->num (zipmap \"abcdefghijklmnopqrstuvwxyzåäö\"\r\n                        (range 29)))\r\n\r\n(defn code-letter [letter key-digit] \r\n    (num->alpha (mod (+ 29 (alpha->num letter) key-digit) 29)))\r\n\r\n(defn code-msg [msg key]\r\n  (when (seq msg)\r\n    (let [letter (first msg)\r\n          key-digit (first key)]\r\n      (if (= letter \\space)\r\n        (cons letter (code-msg (rest msg) key))\r\n        (cons (code-letter letter key-digit)\r\n              (code-msg (rest msg) (rest key)))))))\r\n\r\n(defn encode [input] (apply str (code-msg (str/lower-case input) (cycle key-vector))))\r\n\r\n(defn decode [code] (apply str (code-msg (str/lower-case code) (cycle inv-key))))\r\n\r\n;; HTML helpers\r\n\r\n(defn attach-input-handler! [element-id handler]\r\n  (set! (.-oninput (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn attach-change-handler! [element-id handler]\r\n  (set! (.-onchange (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn set-value! [element-id value]\r\n  (set! (.-value (js/document.getElementById element-id)) value))\r\n\r\n(defn get-value [element-id]\r\n  (.-value (js/document.getElementById element-id)))\r\n\r\n(defn copy-to-clipboard! [value]\r\n  (js/navigator.clipboard.writeText value))\r\n\r\n;; Handlers\r\n\r\n(defn on-encode [arg]\r\n  (set-value! \"decode\" (encode arg)))\r\n\r\n(defn on-decode [arg]\r\n  (set-value! \"encode\" (decode arg)))\r\n\r\n(defn on-change [arg]\r\n  (copy-to-clipboard! (get-value \"decode\"))\r\n  (set-value! \"decode\" \"\")\r\n  (set-value! \"encode\" \"\"))\r\n\r\n(attach-input-handler! \"encode\" on-encode)\r\n(attach-input-handler! \"decode\" on-decode)\r\n(attach-change-handler! \"encode\" on-change)\r\n(attach-change-handler! \"decode\" on-change)\r\n(attach-change-handler! \"key\" (get-value \"key\"))"})}], :file "(ns crypta.core\r\n  \"Crypta\" \r\n  (:require [clojure.string :as str]))\r\n\r\n;(def key-vector [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 1 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7])\r\n(def key-vector (atom [-1 0 -3 2 1 -3 -1 1 5 -7 -4 1 -4 -8 6 -5 2 -6 -2 5 0 4 8 -7]))\r\n\r\n(def inv-key (map - key-vector))\r\n\r\n(def num->alpha (zipmap (range 29)\r\n                        \"abcdefghijklmnopqrstuvwxyzåäö\"))\r\n(def alpha->num (zipmap \"abcdefghijklmnopqrstuvwxyzåäö\"\r\n                        (range 29)))\r\n\r\n(defn code-letter [letter key-digit] \r\n    (num->alpha (mod (+ 29 (alpha->num letter) key-digit) 29)))\r\n\r\n(defn code-msg [msg key]\r\n  (when (seq msg)\r\n    (let [letter (first msg)\r\n          key-digit (first key)]\r\n      (if (= letter \\space)\r\n        (cons letter (code-msg (rest msg) key))\r\n        (cons (code-letter letter key-digit)\r\n              (code-msg (rest msg) (rest key)))))))\r\n\r\n(defn encode [input] (apply str (code-msg (str/lower-case input) (cycle key-vector))))\r\n\r\n(defn decode [code] (apply str (code-msg (str/lower-case code) (cycle inv-key))))\r\n\r\n;; HTML helpers\r\n\r\n(defn attach-input-handler! [element-id handler]\r\n  (set! (.-oninput (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn attach-change-handler! [element-id handler]\r\n  (set! (.-onchange (js/document.getElementById element-id))\r\n        (fn [event] (-> event .-target .-value handler))))\r\n\r\n(defn set-value! [element-id value]\r\n  (set! (.-value (js/document.getElementById element-id)) value))\r\n\r\n(defn get-value [element-id]\r\n  (.-value (js/document.getElementById element-id)))\r\n\r\n(defn copy-to-clipboard! [value]\r\n  (js/navigator.clipboard.writeText value))\r\n\r\n;; Handlers\r\n\r\n(defn on-encode [arg]\r\n  (set-value! \"decode\" (encode arg)))\r\n\r\n(defn on-decode [arg]\r\n  (set-value! \"encode\" (decode arg)))\r\n\r\n(defn on-change [arg]\r\n  (copy-to-clipboard! (get-value \"decode\"))\r\n  (set-value! \"decode\" \"\")\r\n  (set-value! \"encode\" \"\"))\r\n\r\n(attach-input-handler! \"encode\" on-encode)\r\n(attach-input-handler! \"decode\" on-decode)\r\n(attach-change-handler! \"encode\" on-change)\r\n(attach-change-handler! \"decode\" on-change)\r\n(attach-change-handler! \"key\" (get-value \"key\"))"}, :cause #object[TypeError TypeError: Cannot use 'in' operator to search for 'getElementById' in undefined]}
cljs꞉crypta.core꞉> 
